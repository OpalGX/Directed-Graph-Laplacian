%reorder the graph generated by the range-dependent random graph model(RDRG)
%and compare with the original graph
addpath '/Users/gongxue/Documents/Programming/Git code/Higher_order_network/functions'

tic

%initialize parameters
k=3;
a = 0.2; %random noise on the initial attributes
n=1000;
lambda=5;
g_RDRG=1/k; %g parameter for the random graph model
%g_ML = 1/k; %g parameter for the Magnetic Laplacian
%g_ML = [0, 1/k];
g_ML = linspace(1/3,1/3,1);
 %g parameter for the Magnetic Laplacian

%generate random graph
[W, theta, ratioP,f,q] = generateRDRG(k, n, lambda, g_RDRG, a); %will it be disconnected?

%apply ML on the graph to estimate theta
G = digraph(W);
G = max_connected_subgraph(G, 'weak');%take larget weakly connected component
W = adjacency(G);
[Nnodes, ~] = size(G.Nodes);

idx_rand = randperm(Nnodes);%randomize the matrix
W_rand = W(idx_rand,idx_rand);
G_rand = digraph(W_rand);
min_Eta = zeros(1, size(g_ML,2));
opt_k = zeros(1, size(g_ML,2));
gap_10 = zeros(1, size(g_ML,2));
gap_21 = zeros(1, size(g_ML,2));
gap_32 = zeros(1, size(g_ML,2));
eigenvalues = zeros(size(g_ML,2), Nnodes);

img = imagesc(W_rand,[0,1]); %plot color map of original matrix
colorbar;
set(gca,'FontSize',20)
%title(strcat('Adjacency matrix, lambda = ', num2str(lambda)));
saveas(img,strcat('plots/RDRG_rand_k=',num2str(k),'_lambda=',num2str(lambda),'.jpg'));


for i = 1: size(g_ML,2)
    g = g_ML(i);
    
    %applie Magnetic Laplacian
    [G, eig, Phi, D] = meigenmaps(G_rand, g);
    
    %calculate minimum of objective function
    min_Eta(1, i) = eig;
    gap_10(1, i) = D(2)- D(1);
    gap_21(1, i) = D(3)- D(2);
    gap_32(1, i) = D(4)- D(3);
    eigenvalues(i,:) = D;
    
    %find optimal k for clustering based on the polar coordinates of theta
    rng('default');  % For reproducibility
    X = [cos(G.Nodes.phase0), sin(G.Nodes.phase0)];
    eva = evalclusters(X,'kmeans','DaviesBouldin','KList',[1:10]);
    opt_k(1, i) = eva.OptimalK;
    
    %{
    theta_est = G.Nodes.phase0;
    fig = plot(G,'XData', cos(G.Nodes.phase0) ,'YData', sin(G.Nodes.phase0)); %plot on polar coordinate
    xlim([-1.5, 1.5])
    ylim([-1.1, 1.1])
    ax = gca;
    ax.XAxisLocation = 'origin';
    ax.YAxisLocation = 'origin';
    xticks([-1 0 1])
    xticklabels({'\pi','0','0'})
    yticks([-1 0 1])
    yticklabels({'3\pi/2','0','\pi/2'})
    title(strcat('Estimated \theta, g=', num2str(g)));
    saveas(fig,strcat('plots/reorderRDRG_eigmap_',distr,'_lambda=',num2str(lambda),'_k=',num2str(k),'_g=',num2str(g),'.jpg'));
%}
    
    
    %plot the estimate versus the original theta
    fig = scatter(theta, mod(G.Nodes.phase0 - 0.1*pi, 2*pi),'filled')
    xlabel('\theta','FontSize', 13)
    ylabel('Estimated \theta','FontSize', 13)
    xlim([0, 2.1*pi])
    ylim([0, 2.1*pi])
    xticks([0 pi 2*pi])
    xticklabels({'0','\pi','2\pi'})
    yticks([0 pi 2*pi])
    yticklabels({'0','\pi','2\pi'})
    saveas(fig,strcat('plots/reorderRDRG_lambda=',num2str(lambda),'_k=',num2str(k),'_g=',num2str(g),'.jpg'));

    
    %plot the k^2-0.5m^2
    %from i to j
    %img = imagesc(ratioP); %plot color map of original matrix
    %nscale = 11; % should be odd 
    %cmap = flipud(cbrewer('div','RdBu',nscale)); % blues at bottom 
    %caxis([-3 3])
    %colormap(cmap); 
    %colorbar;
    %title(strcat('k^2-0.5m^2, lambda = ', num2str(lambda)));
    %saveas(img,strcat('plots/RDRG_',distr,'_ratioP_lambda=',num2str(lambda),'_g=',num2str(g),'.jpg'));
%}
     
    %plot the adjacency matrix
    [out,idx] = sort(mod(G.Nodes.phase0 - 0.1*pi, 2*pi));
    if (g==0)
        [out,idx] = sort(G.Nodes.phase0);
    end
    W_ordered = W_rand(idx,idx);
    img = imagesc(W_ordered,[0,1]); %plot color map of original matrix
    colorbar;
    set(gca,'FontSize',20)
    %title(strcat('Adjacency matrix, lambda = ', num2str(lambda)));
    saveas(img,strcat('plots/RDRG_k=',num2str(k),'_lambda=',num2str(lambda),'_g=',num2str(g),'.jpg'));

    %{
    %plot the probability of reciprocal edge
    img = imagesc(log10(f)); %plot color map of original matrix
    colorbar;
    title(strcat('P(reciprocal edge), lambda = ', num2str(lambda)));
    %saveas(img,strcat('plots/RDRG_',distr,'_f_lambda=',num2str(lambda),'.jpg'));

    %plot the probability of edge i to j
    img = imagesc(log10(q)); %plot color map of original matrix
    colorbar;
    title(strcat('P(i -> j), lambda = ', num2str(lambda)));
    %saveas(img,strcat('plots/RDRG_',distr,'_q_lambda=',num2str(lambda),'.jpg'));
%}
    
   %plot k^2-0.5m^2, k^2-0.5n^2, versis theta i - theta j
   %{ 
    beta = linspace(0, 2*pi, 100);
    km = 1+cos(beta+2*pi*g)-2*cos(beta);
    kn = 1+cos(beta-2*pi*g)-2*cos(beta);
    k2 = 2-2*cos(beta);
    Z = 1+exp(k2)+exp(km)+exp(kn);
    img=plot(beta, 1./Z, 'DisplayName','i<->j');
    hold on;
    plot(beta, km, 'DisplayName','ratio');
    plot(beta, km./Z, 'DisplayName','i->j');
    xline(2*pi*(1-g_ML),'DisplayName','2\pig');
    yline(0);
    xlabel('\theta_i - \theta_j','FontSize', 13)
    ylabel('Probability','FontSize', 13)
    xlim([0, 2.1*pi])
    xticks([0 pi 2*pi])
    xticklabels({'0','\pi','2\pi'})
    legend();
    title(strcat('g = ', num2str(g)),'FontSize', 13);
    saveas(img,strcat('plots/ratioP_g=',num2str(g_ML),'.jpg'));
    hold off;
    %}
end

img=plot(g_ML, min_Eta,'LineWidth',2);
set(gca,'FontSize',20)
yline(0);
xlabel('g','FontSize', 20)
ylabel('\lambda_0','FontSize', 20)
%xlim([0, 1.1])
%xticks([0 pi 2*pi])
%xticklabels({'0','\pi','2\pi'})
%title(strcat('g_G= ', num2str(g_RDRG), ' \lambda=',num2str(lambda),' n=',num2str(n)) ,'FontSize', 13);
saveas(img,strcat('plots/min_objective_gRDRG=',num2str(g_RDRG),'_lambda=',num2str(lambda),'_n=',num2str(n),'.jpg'));

img=plot(g_ML, opt_k);
xlabel('g','FontSize', 13)
ylabel('Optimal number of clusters','FontSize', 13)
%xlim([0, 1.1])
%xticks([0 pi 2*pi])
%xticklabels({'0','\pi','2\pi'})
%title(strcat('g for Random Graph Model = ', num2str(g_RDRG), ' \lambda=',num2str(lambda),' n=',num2str(n)) ,'FontSize', 13);
saveas(img,strcat('plots/opt_k_gRDRG=',num2str(g_RDRG),'_lambda=',num2str(lambda),'_n=',num2str(n),'.jpg'));


%plot eigenvalues
img = plot(g_ML, min_Eta)
hold on
plot(g_ML, gap_10);
plot(g_ML, gap_21);
plot(g_ML, gap_32);
xlabel('g','FontSize', 13)
hold off
legend({'\lambda_0','\lambda_1-\lambda_0','\lambda_2-\lambda_1','\lambda_3-\lambda_2'},'FontSize', 13);
saveas(img,strcat('plots/spectral_gRDRG=',num2str(g_RDRG),'_lambda=',num2str(lambda),'_n=',num2str(n),'.jpg'));


%plot spectral gap
%img = plot(eigenvalues(1,:))
%hold on
%plot(eigenvalues(2,:))
%plot(eigenvalues(3,:))
%plot(eigenvalues(4,:))
%plot(eigenvalues(5,:))
%plot(eigenvalues(6,:))
%set(gca,'FontSize',13)

%hold off
%legend({'g = 0','g = 0.1','g = 0.2','g = 0.3','g = 0.4','g = 0.5'},'FontSize', 13);
%saveas(img,strcat('plots/eigenvalues_gRDRG=',num2str(g_RDRG),'_lambda=',num2str(lambda),'_n=',num2str(n),'.jpg'));

%find the undirected version and calculate eigenvectors
W_undirected = (W+W' ~= 0);
G_undirected = graph(W_undirected);
plot(G_undirected);

D = degree(G_undirected);
L = diag(D) - W_undirected;
[V, eigenvalue] = eigs(L,size(L,1),'smallestabs');
img = plot(G,'XData', V(:,2) ,'YData', V(:,3)); %plot on polar coordinate
%set(gca,'FontSize',13)
saveas(img,strcat('plots/undirected_gRDRG=',num2str(g_RDRG),'_lambda=',num2str(lambda),'_n=',num2str(n),'.jpg'));

W_norec = W- (W+W' == 2); %remove reciprocal edge
k_max = 10;
n_cycle = zeros(1, k_max);
for i = 1:k_max
    n_cycle(1,i) = sum(diag(W_norec^i));
end
img = plot(log10(n_cycle+1));
xlabel('k','FontSize', 13)
ylabel('log_{10}(# of k cycles +1)','FontSize', 13)
set(gca,'FontSize',13)
saveas(img,strcat('plots/ncycle_gRDRG=',num2str(g_RDRG),'_lambda=',num2str(lambda),'_n=',num2str(n),'.jpg'));

toc